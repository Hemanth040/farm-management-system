const express = require('express');
const router = express.Router();
const mongoose = require('mongoose');
const { Reminder, Warning, NotificationLog, Crop, Field, Activity, Worker, Resource, TimelineActivity } = require('../models');
const auth = require('../middleware/auth');

// ============================================
// REMINDER ROUTES
// ============================================

// GET /api/reminders - List all reminders with filters
router.get('/reminders', auth, async (req, res) => {
    try {
        const { type, status, priority, startDate, endDate, cropId, fieldId, isAutoGenerated, page = 1, limit = 20 } = req.query;
        
        let query = { farmer: req.user.id };
        
        if (type) query.type = type;
        if (status) query.status = status;
        if (priority) query.priority = priority;
        if (cropId) query.crop = cropId;
        if (fieldId) query.field = fieldId;
        if (isAutoGenerated !== undefined) query.isAutoGenerated = isAutoGenerated === 'true';
        
        if (startDate || endDate) {
            query.date = {};
            if (startDate) query.date.$gte = new Date(startDate);
            if (endDate) query.date.$lte = new Date(endDate);
        }
        
        const skip = (page - 1) * limit;
        
        const [reminders, total] = await Promise.all([
            Reminder.find(query)
                .populate('crop', 'name variety')
                .populate('field', 'name')
                .populate('activity', 'title type')
                .populate('worker', 'name phone')
                .populate('resource', 'name category')
                .sort({ date: 1, priority: -1 })
                .skip(skip)
                .limit(parseInt(limit)),
            Reminder.countDocuments(query)
        ]);
        
        res.json({
            reminders,
            pagination: {
                total,
                page: parseInt(page),
                limit: parseInt(limit),
                pages: Math.ceil(total / limit)
            }
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// GET /api/reminders/upcoming - Get upcoming reminders for next 7 days
router.get('/reminders/upcoming', auth, async (req, res) => {
    try {
        const days = parseInt(req.query.days) || 7;
        const today = new Date();
        const futureDate = new Date();
        futureDate.setDate(today.getDate() + days);
        
        const reminders = await Reminder.find({
            farmer: req.user.id,
            date: { $gte: today, $lte: futureDate },
            status: { $in: ['pending', 'snoozed'] }
        })
        .populate('crop', 'name variety')
        .populate('field', 'name')
        .populate('activity', 'title type')
        .populate('worker', 'name phone')
        .sort({ date: 1, priority: -1 });
        
        // Group by date
        const groupedByDate = reminders.reduce((acc, reminder) => {
            const dateKey = reminder.date.toISOString().split('T')[0];
            if (!acc[dateKey]) acc[dateKey] = [];
            acc[dateKey].push(reminder);
            return acc;
        }, {});
        
        res.json({
            reminders,
            groupedByDate,
            count: reminders.length,
            period: { start: today, end: futureDate }
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// GET /api/reminders/today - Get today's reminders
router.get('/reminders/today', auth, async (req, res) => {
    try {
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const tomorrow = new Date(today);
        tomorrow.setDate(tomorrow.getDate() + 1);
        
        const reminders = await Reminder.find({
            farmer: req.user.id,
            date: { $gte: today, $lt: tomorrow },
            status: { $in: ['pending', 'snoozed'] }
        })
        .populate('crop', 'name variety')
        .populate('field', 'name')
        .populate('activity', 'title type')
        .populate('worker', 'name phone')
        .sort({ priority: -1 });
        
        const summary = {
            total: reminders.length,
            highPriority: reminders.filter(r => r.priority === 'high' || r.priority === 'critical').length,
            pending: reminders.filter(r => r.status === 'pending').length,
            snoozed: reminders.filter(r => r.status === 'snoozed').length
        };
        
        res.json({ reminders, summary, date: today });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// POST /api/reminders - Create new reminder
router.post('/reminders', auth, async (req, res) => {
    try {
        const reminderData = {
            ...req.body,
            farmer: req.user.id
        };
        
        const reminder = new Reminder(reminderData);
        await reminder.save();
        
        const populatedReminder = await Reminder.findById(reminder._id)
            .populate('crop', 'name variety')
            .populate('field', 'name')
            .populate('activity', 'title type')
            .populate('worker', 'name phone');
        
        res.status(201).json({
            message: 'Reminder created successfully',
            reminder: populatedReminder
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// PUT /api/reminders/:id - Update reminder
router.put('/reminders/:id', auth, async (req, res) => {
    try {
        const reminder = await Reminder.findOneAndUpdate(
            { _id: req.params.id, farmer: req.user.id },
            { ...req.body, updatedAt: new Date() },
            { new: true }
        )
        .populate('crop', 'name variety')
        .populate('field', 'name')
        .populate('activity', 'title type');
        
        if (!reminder) {
            return res.status(404).json({ error: 'Reminder not found' });
        }
        
        res.json({ message: 'Reminder updated successfully', reminder });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// DELETE /api/reminders/:id - Delete reminder
router.delete('/reminders/:id', auth, async (req, res) => {
    try {
        const reminder = await Reminder.findOneAndDelete({
            _id: req.params.id,
            farmer: req.user.id
        });
        
        if (!reminder) {
            return res.status(404).json({ error: 'Reminder not found' });
        }
        
        res.json({ message: 'Reminder deleted successfully' });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// POST /api/reminders/:id/complete - Mark reminder as completed
router.post('/reminders/:id/complete', auth, async (req, res) => {
    try {
        const { notes } = req.body;
        
        const reminder = await Reminder.findOneAndUpdate(
            { _id: req.params.id, farmer: req.user.id },
            {
                status: 'completed',
                completedAt: new Date(),
                completedBy: req.user.id,
                completionNotes: notes,
                updatedAt: new Date()
            },
            { new: true }
        )
        .populate('crop', 'name variety')
        .populate('field', 'name');
        
        if (!reminder) {
            return res.status(404).json({ error: 'Reminder not found' });
        }
        
        res.json({ message: 'Reminder marked as completed', reminder });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// POST /api/reminders/:id/snooze - Snooze reminder
router.post('/reminders/:id/snooze', auth, async (req, res) => {
    try {
        const { snoozeUntil, snoozeDuration } = req.body;
        
        let snoozeDate;
        if (snoozeUntil) {
            snoozeDate = new Date(snoozeUntil);
        } else if (snoozeDuration) {
            snoozeDate = new Date();
            snoozeDate.setMinutes(snoozeDate.getMinutes() + parseInt(snoozeDuration));
        } else {
            // Default snooze 1 hour
            snoozeDate = new Date();
            snoozeDate.setHours(snoozeDate.getHours() + 1);
        }
        
        const reminder = await Reminder.findOneAndUpdate(
            { _id: req.params.id, farmer: req.user.id },
            {
                status: 'snoozed',
                'snooze.snoozedUntil': snoozeDate,
                $inc: { 'snooze.snoozeCount': 1 },
                updatedAt: new Date()
            },
            { new: true }
        );
        
        if (!reminder) {
            return res.status(404).json({ error: 'Reminder not found' });
        }
        
        res.json({
            message: 'Reminder snoozed',
            reminder,
            snoozedUntil: snoozeDate
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// POST /api/reminders/:id/cancel - Cancel reminder
router.post('/reminders/:id/cancel', auth, async (req, res) => {
    try {
        const { reason } = req.body;
        
        const reminder = await Reminder.findOneAndUpdate(
            { _id: req.params.id, farmer: req.user.id },
            {
                status: 'cancelled',
                completionNotes: reason,
                updatedAt: new Date()
            },
            { new: true }
        );
        
        if (!reminder) {
            return res.status(404).json({ error: 'Reminder not found' });
        }
        
        res.json({ message: 'Reminder cancelled', reminder });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// GET /api/reminders/stats - Get reminder statistics
router.get('/reminders/stats', auth, async (req, res) => {
    try {
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const startOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);
        
        const stats = await Reminder.aggregate([
            { $match: { farmer: new mongoose.Types.ObjectId(req.user.id) } },
            {
                $group: {
                    _id: null,
                    total: { $sum: 1 },
                    pending: { $sum: { $cond: [{ $eq: ['$status', 'pending'] }, 1, 0] } },
                    completed: { $sum: { $cond: [{ $eq: ['$status', 'completed'] }, 1, 0] } },
                    snoozed: { $sum: { $cond: [{ $eq: ['$status', 'snoozed'] }, 1, 0] } },
                    cancelled: { $sum: { $cond: [{ $eq: ['$status', 'cancelled'] }, 1, 0] } },
                    highPriority: { $sum: { $cond: [{ $eq: ['$priority', 'high'] }, 1, 0] } },
                    criticalPriority: { $sum: { $cond: [{ $eq: ['$priority', 'critical'] }, 1, 0] } },
                    overdue: {
                        $sum: {
                            $cond: [
                                { $and: [
                                    { $eq: ['$status', 'pending'] },
                                    { $lt: ['$date', today] }
                                ]},
                                1,
                                0
                            ]
                        }
                    },
                    autoGenerated: { $sum: { $cond: [{ $eq: ['$isAutoGenerated', true] }, 1, 0] } }
                }
            }
        ]);
        
        const typeStats = await Reminder.aggregate([
            { $match: { farmer: new mongoose.Types.ObjectId(req.user.id) } },
            {
                $group: {
                    _id: '$type',
                    count: { $sum: 1 },
                    pending: { $sum: { $cond: [{ $eq: ['$status', 'pending'] }, 1, 0] } }
                }
            }
        ]);
        
        const thisMonthCount = await Reminder.countDocuments({
            farmer: req.user.id,
            createdAt: { $gte: startOfMonth }
        });
        
        const statsData = stats[0] || {
            total: 0, pending: 0, completed: 0, snoozed: 0,
            cancelled: 0, highPriority: 0, criticalPriority: 0, overdue: 0, autoGenerated: 0
        };
        
        res.json({
            ...statsData,
            typeBreakdown: typeStats,
            thisMonthCreated: thisMonthCount
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// ============================================
// WARNING ROUTES
// ============================================

// GET /api/warnings - List all warnings with filters
router.get('/warnings', auth, async (req, res) => {
    try {
        const { type, severity, status, isRead, cropId, fieldId, isAutoGenerated, page = 1, limit = 20 } = req.query;
        
        let query = { farmer: req.user.id };
        
        if (type) query.type = type;
        if (severity) query.severity = severity;
        if (status) query.status = status;
        if (isRead !== undefined) query.isRead = isRead === 'true';
        if (cropId) query.crop = cropId;
        if (fieldId) query.field = fieldId;
        if (isAutoGenerated !== undefined) query.isAutoGenerated = isAutoGenerated === 'true';
        
        const skip = (page - 1) * limit;
        
        const [warnings, total] = await Promise.all([
            Warning.find(query)
                .populate('crop', 'name variety')
                .populate('field', 'name')
                .populate('activity', 'title type')
                .populate('worker', 'name phone')
                .populate('resource', 'name category')
                .sort({ priority: -1, createdAt: -1 })
                .skip(skip)
                .limit(parseInt(limit)),
            Warning.countDocuments(query)
        ]);
        
        res.json({
            warnings,
            pagination: {
                total,
                page: parseInt(page),
                limit: parseInt(limit),
                pages: Math.ceil(total / limit)
            }
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// GET /api/warnings/active - Get active warnings only
router.get('/warnings/active', auth, async (req, res) => {
    try {
        const warnings = await Warning.find({
            farmer: req.user.id,
            status: { $in: ['active', 'acknowledged'] },
            $or: [
                { validUntil: { $gte: new Date() } },
                { validUntil: null }
            ]
        })
        .populate('crop', 'name variety')
        .populate('field', 'name')
        .populate('activity', 'title type')
        .sort({ severity: -1, priority: -1, createdAt: -1 });
        
        // Group by severity
        const grouped = {
            critical: warnings.filter(w => w.severity === 'critical'),
            high: warnings.filter(w => w.severity === 'high'),
            medium: warnings.filter(w => w.severity === 'medium'),
            low: warnings.filter(w => w.severity === 'low'),
            informational: warnings.filter(w => w.severity === 'informational')
        };
        
        res.json({
            warnings,
            grouped,
            count: warnings.length,
            criticalCount: grouped.critical.length,
            highCount: grouped.high.length
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// GET /api/warnings/unread - Get unread warnings count
router.get('/warnings/unread', auth, async (req, res) => {
    try {
        const unreadCount = await Warning.countDocuments({
            farmer: req.user.id,
            isRead: false,
            status: { $in: ['active', 'acknowledged'] }
        });
        
        const bySeverity = await Warning.aggregate([
            {
                $match: {
                    farmer: new mongoose.Types.ObjectId(req.user.id),
                    isRead: false,
                    status: { $in: ['active', 'acknowledged'] }
                }
            },
            {
                $group: {
                    _id: '$severity',
                    count: { $sum: 1 }
                }
            }
        ]);
        
        res.json({
            unreadCount,
            bySeverity: bySeverity.reduce((acc, item) => {
                acc[item._id] = item.count;
                return acc;
            }, {})
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// POST /api/warnings - Create warning (supervisor/system)
router.post('/warnings', auth, async (req, res) => {
    try {
        const warningData = {
            ...req.body,
            farmer: req.user.id,
            source: req.body.source || 'supervisor',
            isAutoGenerated: req.body.source === 'system'
        };
        
        const warning = new Warning(warningData);
        await warning.save();
        
        const populatedWarning = await Warning.findById(warning._id)
            .populate('crop', 'name variety')
            .populate('field', 'name')
            .populate('activity', 'title type')
            .populate('worker', 'name phone');
        
        res.status(201).json({
            message: 'Warning created successfully',
            warning: populatedWarning
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// GET /api/warnings/:id - Get warning details
router.get('/warnings/:id', auth, async (req, res) => {
    try {
        const warning = await Warning.findOne({
            _id: req.params.id,
            farmer: req.user.id
        })
        .populate('crop', 'name variety')
        .populate('field', 'name location')
        .populate('activity', 'title type status')
        .populate('worker', 'name phone role')
        .populate('resource', 'name category quantity')
        .populate('acknowledgedBy', 'name')
        .populate('resolvedBy', 'name')
        .populate('dismissedBy', 'name');
        
        if (!warning) {
            return res.status(404).json({ error: 'Warning not found' });
        }
        
        res.json(warning);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// PUT /api/warnings/:id/acknowledge - Acknowledge warning
router.put('/warnings/:id/acknowledge', auth, async (req, res) => {
    try {
        const warning = await Warning.findOneAndUpdate(
            { _id: req.params.id, farmer: req.user.id },
            {
                status: 'acknowledged',
                isRead: true,
                acknowledgedAt: new Date(),
                acknowledgedBy: req.user.id,
                updatedAt: new Date()
            },
            { new: true }
        );
        
        if (!warning) {
            return res.status(404).json({ error: 'Warning not found' });
        }
        
        res.json({ message: 'Warning acknowledged', warning });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// PUT /api/warnings/:id/resolve - Resolve warning with action taken
router.put('/warnings/:id/resolve', auth, async (req, res) => {
    try {
        const { actionTaken, notes } = req.body;
        
        const warning = await Warning.findOneAndUpdate(
            { _id: req.params.id, farmer: req.user.id },
            {
                status: 'resolved',
                actionTaken: actionTaken || notes,
                resolvedAt: new Date(),
                resolvedBy: req.user.id,
                updatedAt: new Date()
            },
            { new: true }
        );
        
        if (!warning) {
            return res.status(404).json({ error: 'Warning not found' });
        }
        
        res.json({ message: 'Warning resolved', warning });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// PUT /api/warnings/:id/dismiss - Dismiss warning
router.put('/warnings/:id/dismiss', auth, async (req, res) => {
    try {
        const { reason } = req.body;
        
        const warning = await Warning.findOneAndUpdate(
            { _id: req.params.id, farmer: req.user.id },
            {
                status: 'dismissed',
                dismissedAt: new Date(),
                dismissedBy: req.user.id,
                dismissReason: reason,
                updatedAt: new Date()
            },
            { new: true }
        );
        
        if (!warning) {
            return res.status(404).json({ error: 'Warning not found' });
        }
        
        res.json({ message: 'Warning dismissed', warning });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// POST /api/warnings/bulk-acknowledge - Acknowledge multiple warnings
router.post('/warnings/bulk-acknowledge', auth, async (req, res) => {
    try {
        const { warningIds } = req.body;
        
        if (!Array.isArray(warningIds) || warningIds.length === 0) {
            return res.status(400).json({ error: 'No warning IDs provided' });
        }
        
        const result = await Warning.updateMany(
            {
                _id: { $in: warningIds },
                farmer: req.user.id,
                status: 'active'
            },
            {
                status: 'acknowledged',
                isRead: true,
                acknowledgedAt: new Date(),
                acknowledgedBy: req.user.id,
                updatedAt: new Date()
            }
        );
        
        res.json({
            message: `${result.modifiedCount} warnings acknowledged`,
            acknowledgedCount: result.modifiedCount
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// ============================================
// AUTO-GENERATION ROUTES
// ============================================

// POST /api/warnings/auto-generate - Auto-generate warnings from system data
router.post('/warnings/auto-generate', auth, async (req, res) => {
    try {
        const { types } = req.body; // Array of warning types to generate
        const generatedWarnings = [];
        
        // Activity delay warnings
        if (!types || types.includes('activity_delay')) {
            const overdueActivities = await TimelineActivity.find({
                farmer: req.user.id,
                plannedDate: { $lt: new Date() },
                status: { $in: ['pending', 'in-progress'] }
            }).populate('crop', 'name');
            
            for (const activity of overdueActivities) {
                const daysOverdue = Math.floor((new Date() - activity.plannedDate) / (1000 * 60 * 60 * 24));
                
                const warning = await Warning.findOneAndUpdate(
                    {
                        farmer: req.user.id,
                        activity: activity._id,
                        category: 'activity_overdue',
                        status: { $in: ['active', 'acknowledged'] }
                    },
                    {
                        title: `Overdue Activity: ${activity.title}`,
                        message: `Activity "${activity.title}" for ${activity.crop?.name || 'crop'} is ${daysOverdue} days overdue`,
                        severity: daysOverdue > 7 ? 'high' : 'medium',
                        details: `Planned for ${activity.plannedDate.toDateString()} but still pending`,
                        actionRequired: 'Complete or reschedule the activity',
                        isAutoGenerated: true,
                        source: 'system',
                        updatedAt: new Date()
                    },
                    { upsert: true, new: true }
                );
                
                if (warning) generatedWarnings.push(warning);
            }
        }
        
        res.json({
            message: `Generated ${generatedWarnings.length} warnings`,
            warnings: generatedWarnings
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// POST /api/reminders/auto-generate - Auto-generate reminders from crop planner
router.post('/reminders/auto-generate', auth, async (req, res) => {
    try {
        const generatedReminders = [];
        
        // Get all active crops
        const crops = await Crop.find({
            farmer: req.user.id,
            status: { $in: ['sowed', 'growing'] }
        });
        
        for (const crop of crops) {
            const daysSinceSowing = Math.floor((new Date() - crop.sowingDate) / (1000 * 60 * 60 * 24));
            
            // Check for upcoming harvest
            const daysToHarvest = Math.floor((crop.expectedHarvestDate - new Date()) / (1000 * 60 * 60 * 24));
            
            if (daysToHarvest <= 30 && daysToHarvest > 0) {
                const reminder = await Reminder.findOneAndUpdate(
                    {
                        farmer: req.user.id,
                        crop: crop._id,
                        category: 'harvesting',
                        status: 'pending'
                    },
                    {
                        title: `Harvest Approaching: ${crop.name}`,
                        description: `${crop.name} (${crop.variety}) expected harvest in ${daysToHarvest} days`,
                        date: crop.expectedHarvestDate,
                        type: 'harvest',
                        priority: daysToHarvest <= 7 ? 'high' : 'medium',
                        isAutoGenerated: true,
                        source: 'crop_planner',
                        updatedAt: new Date()
                    },
                    { upsert: true, new: true }
                );
                
                if (reminder) generatedReminders.push(reminder);
            }
        }
        
        res.json({
            message: `Generated ${generatedReminders.length} reminders`,
            reminders: generatedReminders
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// GET /api/warnings/generate/weather - Generate weather warnings
router.get('/warnings/generate/weather', auth, async (req, res) => {
    try {
        // Mock weather warning generation
        // In real implementation, this would fetch weather API data
        
        res.json({
            message: 'Weather warning generation initiated',
            generated: 0,
            note: 'Integrate with weather API for actual weather warnings'
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// GET /api/warnings/generate/activity-delays - Generate activity delay warnings
router.get('/warnings/generate/activity-delays', auth, async (req, res) => {
    try {
        const overdueActivities = await TimelineActivity.find({
            farmer: req.user.id,
            plannedDate: { $lt: new Date() },
            status: { $in: ['pending', 'in-progress'] }
        }).populate('crop', 'name');
        
        const generatedWarnings = [];
        
        for (const activity of overdueActivities) {
            const daysOverdue = Math.floor((new Date() - activity.plannedDate) / (1000 * 60 * 60 * 24));
            
            const warning = await Warning.findOneAndUpdate(
                {
                    farmer: req.user.id,
                    activity: activity._id,
                    category: 'activity_overdue',
                    status: { $in: ['active', 'acknowledged'] }
                },
                {
                    title: `Overdue: ${activity.title}`,
                    message: `Activity is ${daysOverdue} days overdue`,
                    severity: daysOverdue > 7 ? 'high' : 'medium',
                    type: 'activity_delay',
                    category: 'activity_overdue',
                    details: `Planned for ${activity.plannedDate.toDateString()}`,
                    actionRequired: 'Complete or reschedule the activity',
                    suggestedActions: [
                        { action: 'Mark as complete', priority: 'immediate' },
                        { action: 'Reschedule to later date', priority: 'soon' }
                    ],
                    isAutoGenerated: true,
                    source: 'system',
                    updatedAt: new Date()
                },
                { upsert: true, new: true }
            );
            
            generatedWarnings.push(warning);
        }
        
        res.json({
            message: `Generated ${generatedWarnings.length} activity delay warnings`,
            warnings: generatedWarnings
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// GET /api/warnings/generate/resource-alerts - Generate resource low/expiry warnings
router.get('/warnings/generate/resource-alerts', auth, async (req, res) => {
    try {
        const lowResources = await Resource.find({
            farmer: req.user.id,
            $expr: { $lte: ['$quantity', '$minQuantity'] }
        });
        
        const expiringResources = await Resource.find({
            farmer: req.user.id,
            expiryDate: { $lte: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), $gte: new Date() }
        });
        
        const generatedWarnings = [];
        
        // Low stock warnings
        for (const resource of lowResources) {
            const warning = await Warning.findOneAndUpdate(
                {
                    farmer: req.user.id,
                    resource: resource._id,
                    category: 'resource_low',
                    status: { $in: ['active', 'acknowledged'] }
                },
                {
                    title: `Low Stock: ${resource.name}`,
                    message: `${resource.name} is running low (${resource.quantity} ${resource.unit} remaining)`,
                    severity: 'medium',
                    type: 'resource',
                    category: 'resource_low',
                    actionRequired: 'Restock the resource',
                    isAutoGenerated: true,
                    source: 'system',
                    updatedAt: new Date()
                },
                { upsert: true, new: true }
            );
            
            generatedWarnings.push(warning);
        }
        
        // Expiry warnings
        for (const resource of expiringResources) {
            const daysToExpiry = Math.floor((resource.expiryDate - new Date()) / (1000 * 60 * 60 * 24));
            
            const warning = await Warning.findOneAndUpdate(
                {
                    farmer: req.user.id,
                    resource: resource._id,
                    category: 'resource_expiry',
                    status: { $in: ['active', 'acknowledged'] }
                },
                {
                    title: `Expiring Soon: ${resource.name}`,
                    message: `${resource.name} expires in ${daysToExpiry} days`,
                    severity: daysToExpiry <= 7 ? 'high' : 'medium',
                    type: 'resource',
                    category: 'resource_expiry',
                    actionRequired: 'Use or dispose of resource before expiry',
                    isAutoGenerated: true,
                    source: 'system',
                    updatedAt: new Date()
                },
                { upsert: true, new: true }
            );
            
            generatedWarnings.push(warning);
        }
        
        res.json({
            message: `Generated ${generatedWarnings.length} resource warnings`,
            lowStock: lowResources.length,
            expiringSoon: expiringResources.length,
            warnings: generatedWarnings
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// ============================================
// NOTIFICATION ROUTES
// ============================================

// POST /api/notifications/send - Send notifications via different channels
router.post('/notifications/send', auth, async (req, res) => {
    try {
        const { entityType, entityId, channels, content } = req.body;
        
        if (!['reminder', 'warning'].includes(entityType)) {
            return res.status(400).json({ error: 'Invalid entity type' });
        }
        
        const entity = entityType === 'reminder' 
            ? await Reminder.findOne({ _id: entityId, farmer: req.user.id })
            : await Warning.findOne({ _id: entityId, farmer: req.user.id });
        
        if (!entity) {
            return res.status(404).json({ error: `${entityType} not found` });
        }
        
        const notificationResults = [];
        
        for (const channel of channels || ['in_app']) {
            const log = new NotificationLog({
                farmer: req.user.id,
                type: entityType,
                entity: entityId,
                entityModel: entityType === 'reminder' ? 'Reminder' : 'Warning',
                channel: channel === 'push' ? 'push' : channel,
                content: content || entity.title,
                status: 'sent',
                sentAt: new Date()
            });
            
            await log.save();
            notificationResults.push({ channel, status: 'sent', logId: log._id });
        }
        
        // Update entity notification status
        if (entityType === 'reminder') {
            await Reminder.findByIdAndUpdate(entityId, { notificationSent: true });
        } else {
            await Warning.findByIdAndUpdate(entityId, { 
                notificationSent: true, 
                notificationSentAt: new Date() 
            });
        }
        
        res.json({
            message: 'Notifications sent',
            results: notificationResults
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// GET /api/notifications/history - Get notification history
router.get('/notifications/history', auth, async (req, res) => {
    try {
        const { entityType, status, startDate, endDate, page = 1, limit = 20 } = req.query;
        
        let query = { farmer: req.user.id };
        
        if (entityType) query.type = entityType;
        if (status) query.status = status;
        if (startDate || endDate) {
            query.sentAt = {};
            if (startDate) query.sentAt.$gte = new Date(startDate);
            if (endDate) query.sentAt.$lte = new Date(endDate);
        }
        
        const skip = (page - 1) * limit;
        
        const [notifications, total] = await Promise.all([
            NotificationLog.find(query)
                .populate('entity')
                .sort({ sentAt: -1 })
                .skip(skip)
                .limit(parseInt(limit)),
            NotificationLog.countDocuments(query)
        ]);
        
        res.json({
            notifications,
            pagination: {
                total,
                page: parseInt(page),
                limit: parseInt(limit),
                pages: Math.ceil(total / limit)
            }
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// GET /api/notifications/settings - Get notification preferences
router.get('/notifications/settings', auth, async (req, res) => {
    try {
        // This would typically fetch from a UserPreferences model
        // For now, returning default settings structure
        res.json({
            settings: {
                reminders: {
                    inApp: true,
                    push: true,
                    sms: false,
                    email: false,
                    advanceNotice: 24 // hours
                },
                warnings: {
                    critical: { inApp: true, push: true, sms: true, email: true },
                    high: { inApp: true, push: true, sms: false, email: true },
                    medium: { inApp: true, push: true, sms: false, email: false },
                    low: { inApp: true, push: false, sms: false, email: false }
                },
                quietHours: {
                    enabled: false,
                    start: '22:00',
                    end: '07:00'
                }
            }
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// PUT /api/notifications/settings - Update notification preferences
router.put('/notifications/settings', auth, async (req, res) => {
    try {
        const { settings } = req.body;
        
        // This would typically update a UserPreferences model
        // For now, just returning success
        res.json({
            message: 'Notification settings updated',
            settings: settings
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// ============================================
// ANALYTICS ROUTES
// ============================================

// GET /api/warnings/analytics - Get warning analytics
router.get('/warnings/analytics', auth, async (req, res) => {
    try {
        const { startDate, endDate } = req.query;
        const start = startDate ? new Date(startDate) : new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
        const end = endDate ? new Date(endDate) : new Date();
        
        // Overall stats
        const overallStats = await Warning.aggregate([
            {
                $match: {
                    farmer: new mongoose.Types.ObjectId(req.user.id),
                    createdAt: { $gte: start, $lte: end }
                }
            },
            {
                $group: {
                    _id: null,
                    total: { $sum: 1 },
                    active: { $sum: { $cond: [{ $eq: ['$status', 'active'] }, 1, 0] } },
                    resolved: { $sum: { $cond: [{ $eq: ['$status', 'resolved'] }, 1, 0] } },
                    acknowledged: { $sum: { $cond: [{ $eq: ['$status', 'acknowledged'] }, 1, 0] } },
                    dismissed: { $sum: { $cond: [{ $eq: ['$status', 'dismissed'] }, 1, 0] } },
                    avgResolutionTime: {
                        $avg: {
                            $cond: [
                                { $and: ['$resolvedAt', '$createdAt'] },
                                { $subtract: ['$resolvedAt', '$createdAt'] },
                                null
                            ]
                        }
                    }
                }
            }
        ]);
        
        // By type
        const byType = await Warning.aggregate([
            {
                $match: {
                    farmer: new mongoose.Types.ObjectId(req.user.id),
                    createdAt: { $gte: start, $lte: end }
                }
            },
            {
                $group: {
                    _id: '$type',
                    count: { $sum: 1 },
                    active: { $sum: { $cond: [{ $eq: ['$status', 'active'] }, 1, 0] } }
                }
            }
        ]);
        
        // By severity
        const bySeverity = await Warning.aggregate([
            {
                $match: {
                    farmer: new mongoose.Types.ObjectId(req.user.id),
                    createdAt: { $gte: start, $lte: end }
                }
            },
            {
                $group: {
                    _id: '$severity',
                    count: { $sum: 1 },
                    resolved: { $sum: { $cond: [{ $eq: ['$status', 'resolved'] }, 1, 0] } }
                }
            }
        ]);
        
        // Daily trend
        const dailyTrend = await Warning.aggregate([
            {
                $match: {
                    farmer: new mongoose.Types.ObjectId(req.user.id),
                    createdAt: { $gte: start, $lte: end }
                }
            },
            {
                $group: {
                    _id: { $dateToString: { format: '%Y-%m-%d', date: '$createdAt' } },
                    count: { $sum: 1 },
                    critical: { $sum: { $cond: [{ $eq: ['$severity', 'critical'] }, 1, 0] } }
                }
            },
            { $sort: { _id: 1 } }
        ]);
        
        res.json({
            period: { start, end },
            overall: overallStats[0] || { total: 0, active: 0, resolved: 0, acknowledged: 0, dismissed: 0 },
            byType,
            bySeverity,
            dailyTrend
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// GET /api/reminders/analytics - Get reminder analytics
router.get('/reminders/analytics', auth, async (req, res) => {
    try {
        const { startDate, endDate } = req.query;
        const start = startDate ? new Date(startDate) : new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
        const end = endDate ? new Date(endDate) : new Date();
        
        // Overall stats
        const overallStats = await Reminder.aggregate([
            {
                $match: {
                    farmer: new mongoose.Types.ObjectId(req.user.id),
                    createdAt: { $gte: start, $lte: end }
                }
            },
            {
                $group: {
                    _id: null,
                    total: { $sum: 1 },
                    completed: { $sum: { $cond: [{ $eq: ['$status', 'completed'] }, 1, 0] } },
                    pending: { $sum: { $cond: [{ $eq: ['$status', 'pending'] }, 1, 0] } },
                    snoozed: { $sum: { $cond: [{ $eq: ['$status', 'snoozed'] }, 1, 0] } },
                    cancelled: { $sum: { $cond: [{ $eq: ['$status', 'cancelled'] }, 1, 0] } },
                    completionRate: {
                        $avg: { $cond: [{ $eq: ['$status', 'completed'] }, 1, 0] }
                    }
                }
            }
        ]);
        
        // By type
        const byType = await Reminder.aggregate([
            {
                $match: {
                    farmer: new mongoose.Types.ObjectId(req.user.id),
                    createdAt: { $gte: start, $lte: end }
                }
            },
            {
                $group: {
                    _id: '$type',
                    count: { $sum: 1 },
                    completed: { $sum: { $cond: [{ $eq: ['$status', 'completed'] }, 1, 0] } }
                }
            }
        ]);
        
        // By priority
        const byPriority = await Reminder.aggregate([
            {
                $match: {
                    farmer: new mongoose.Types.ObjectId(req.user.id),
                    createdAt: { $gte: start, $lte: end }
                }
            },
            {
                $group: {
                    _id: '$priority',
                    count: { $sum: 1 },
                    completed: { $sum: { $cond: [{ $eq: ['$status', 'completed'] }, 1, 0] } }
                }
            }
        ]);
        
        // Completion time analysis
        const completionTimeStats = await Reminder.aggregate([
            {
                $match: {
                    farmer: new mongoose.Types.ObjectId(req.user.id),
                    status: 'completed',
                    completedAt: { $exists: true },
                    date: { $exists: true }
                }
            },
            {
                $project: {
                    completionDelay: { $subtract: ['$completedAt', '$date'] }
                }
            },
            {
                $group: {
                    _id: null,
                    avgDelay: { $avg: '$completionDelay' },
                    minDelay: { $min: '$completionDelay' },
                    maxDelay: { $max: '$completionDelay' }
                }
            }
        ]);
        
        // Daily trend
        const dailyTrend = await Reminder.aggregate([
            {
                $match: {
                    farmer: new mongoose.Types.ObjectId(req.user.id),
                    createdAt: { $gte: start, $lte: end }
                }
            },
            {
                $group: {
                    _id: { $dateToString: { format: '%Y-%m-%d', date: '$createdAt' } },
                    created: { $sum: 1 },
                    completed: { $sum: { $cond: [{ $eq: ['$status', 'completed'] }, 1, 0] } }
                }
            },
            { $sort: { _id: 1 } }
        ]);
        
        res.json({
            period: { start, end },
            overall: overallStats[0] || { total: 0, completed: 0, pending: 0, snoozed: 0, cancelled: 0, completionRate: 0 },
            byType,
            byPriority,
            completionTime: completionTimeStats[0] || null,
            dailyTrend
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

module.exports = router;
